# 设计模式

软件开发不变的真理 --Change

名词解释: Object Oriented 面向对象(OO)

OO基本概念：抽象、封装、继承、多态

设计原则：

- 封装变化:找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混淆在一起

- 针对接口编程，而不是针对实现编程

- 多用组合，少用继承

## 设计模式之策略模式 | Strategy Pattern

从名字上我们很难理解这个设计模式适用于什么情况下，什么情况下使用这个设计模式更合理，他有哪些优点，在最后我们再对策略模式的概念所出解释

### 首先，让我们从一个例子的需求入手，一步一步的来了解如何用策略模式解决开发中遇到的问题

模拟鸭子游戏：要求游戏中会出现各种鸭子，一边游泳戏水，一边呱呱叫。现在我们使用标准的OO原则，设计一个鸭子超类，并让各种鸭子继承此超类

![strategy01](https://github.com/CoderGuoy/AndroidNote/blob/master/screenshots/strategy01.png)

OK，对于这个需求我们可以很容的就实现，那么现在我们又有了新的需求，让鸭子能飞，这似乎并不难

我们只需要在Duck的类中加上fly()方法，然后所有鸭子都会继承fly()

![strategy02](https://github.com/CoderGuoy/AndroidNote/blob/master/screenshots/strategy02.png)

但是，可怕的问题发生了，游戏中的很多"橡皮鸭子"在屏幕上飞来飞去，这样就很不合理

![strategy03](https://github.com/CoderGuoy/AndroidNote/blob/master/screenshots/strategy03.png)

当涉及到"维护"时，为了"复用"目的而使用继承，结果并不完美

![strategy04](https://github.com/CoderGuoy/AndroidNote/blob/master/screenshots/strategy04.png)

当然，我们可以把橡皮鸭中的fly()方法覆盖掉，就好像覆盖quack()的做法一样

![strategy05](https://github.com/CoderGuoy/AndroidNote/blob/master/screenshots/strategy05.png)

可是，如果以后加入木头鸭呢？木头鸭又不会飞也不会叫

![strategy06](https://github.com/CoderGuoy/AndroidNote/blob/master/screenshots/strategy06.png)

这是继承层次中另一个类，注意：木头鸭不会飞也不会叫，可是橡皮鸭会叫不会飞

利用继承来提供Duck的行为，会导致以下四个缺点：

- 代码在多个子类中重复

- 运行时的行为不容易改变

- 很难知道所有鸭子的全部行为

- 改变会牵一发而动全身，造成其它鸭子不想要的改变

### 利用接口如何？

每当有新的鸭子子类出现，我们就要检查并可能需要覆盖fly()和quark()，这简直就是无穷无尽的噩梦

所以，我们需要一个更清晰的方法，让"某些"(不是全部)鸭子类型可飞或可叫

我们可以把fly()从超类中提取出来，放进一个"FlayAble接口"中，这么一来，只有会飞的鸭子才实现此接口，同样的方式，也可以用来设计一个"QuackAble接口"，因为不是所有的鸭子都会叫

![strategy07](https://github.com/CoderGuoy/AndroidNote/blob/master/screenshots/strategy07.png)

仔细想一想，并非"所有"的子类都具有飞行和呱呱叫的行为，所以接口可以解决"一部分"的问题，但是却造成代码无法复用。

### 封装变化

现在发现继承并不能很好的解决问题，因为鸭子的行为在子类里不断的改变，并且让所有的子类都有这些行为是不恰当的，接口一开始似乎还不错，解决了一部分的问题，但是java接口不具有实现代码，所以继承接口无法达到代码的复用，这意味着：无论何时修改某个行为，必须得往下追踪并在每一个定义此行为的类中修改它。

设计原则：封装变化(找出可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起)

换句话说，如果每次新的需求一来，都会使某方面的代码发生变化，那么你就可以确定，这部分的代码需要被抽出来，和其他稳定的代码有所区分。

目前所知，除了fly()和quack()的问题之外，Duck类还算一切正常，所以除了某些小改变之外，不对Duck类进行太多处理。




